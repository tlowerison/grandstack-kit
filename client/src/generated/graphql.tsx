// Code generated by `yarn gqlgen`, DO NOT EDIT.
/* eslint-disable @typescript-eslint/explicit-function-return-type, @typescript-eslint/no-explicit-any, no-irregular-whitespace */
/* eslint-disable no-duplicate-imports */
import { gql } from "@apollo/client";
import * as Apollo from "@apollo/client";
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
// Generated on 2021-01-13T03:16:26-08:00

/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};


export enum Role {
  Admin = "ADMIN",
  Server = "SERVER",
  User = "USER"
}

export enum Scope {
  WriteMe = "WRITE_ME",
  DeleteMe = "DELETE_ME"
}

export enum _UserOrdering {
  UuidAsc = "uuid_asc",
  UuidDesc = "uuid_desc",
  EmailAsc = "email_asc",
  EmailDesc = "email_desc",
  UsernameAsc = "username_asc",
  UsernameDesc = "username_desc",
  PasswordAsc = "password_asc",
  PasswordDesc = "password_desc",
  DescriptionAsc = "description_asc",
  DescriptionDesc = "description_desc",
  IdAsc = "_id_asc",
  IdDesc = "_id_desc"
}

export type _UserFilter = {
  AND?: Maybe<Array<_UserFilter>>;
  OR?: Maybe<Array<_UserFilter>>;
  uuid?: Maybe<Scalars["ID"]>;
  uuid_not?: Maybe<Scalars["ID"]>;
  uuid_in?: Maybe<Array<Scalars["ID"]>>;
  uuid_not_in?: Maybe<Array<Scalars["ID"]>>;
  uuid_contains?: Maybe<Scalars["ID"]>;
  uuid_not_contains?: Maybe<Scalars["ID"]>;
  uuid_starts_with?: Maybe<Scalars["ID"]>;
  uuid_not_starts_with?: Maybe<Scalars["ID"]>;
  uuid_ends_with?: Maybe<Scalars["ID"]>;
  uuid_not_ends_with?: Maybe<Scalars["ID"]>;
  email?: Maybe<Scalars["String"]>;
  email_not?: Maybe<Scalars["String"]>;
  email_in?: Maybe<Array<Scalars["String"]>>;
  email_not_in?: Maybe<Array<Scalars["String"]>>;
  email_contains?: Maybe<Scalars["String"]>;
  email_not_contains?: Maybe<Scalars["String"]>;
  email_starts_with?: Maybe<Scalars["String"]>;
  email_not_starts_with?: Maybe<Scalars["String"]>;
  email_ends_with?: Maybe<Scalars["String"]>;
  email_not_ends_with?: Maybe<Scalars["String"]>;
  username?: Maybe<Scalars["String"]>;
  username_not?: Maybe<Scalars["String"]>;
  username_in?: Maybe<Array<Scalars["String"]>>;
  username_not_in?: Maybe<Array<Scalars["String"]>>;
  username_contains?: Maybe<Scalars["String"]>;
  username_not_contains?: Maybe<Scalars["String"]>;
  username_starts_with?: Maybe<Scalars["String"]>;
  username_not_starts_with?: Maybe<Scalars["String"]>;
  username_ends_with?: Maybe<Scalars["String"]>;
  username_not_ends_with?: Maybe<Scalars["String"]>;
  password?: Maybe<Scalars["String"]>;
  password_not?: Maybe<Scalars["String"]>;
  password_in?: Maybe<Array<Scalars["String"]>>;
  password_not_in?: Maybe<Array<Scalars["String"]>>;
  password_contains?: Maybe<Scalars["String"]>;
  password_not_contains?: Maybe<Scalars["String"]>;
  password_starts_with?: Maybe<Scalars["String"]>;
  password_not_starts_with?: Maybe<Scalars["String"]>;
  password_ends_with?: Maybe<Scalars["String"]>;
  password_not_ends_with?: Maybe<Scalars["String"]>;
  roles?: Maybe<Array<Role>>;
  roles_not?: Maybe<Array<Role>>;
  description?: Maybe<Scalars["String"]>;
  description_not?: Maybe<Scalars["String"]>;
  description_in?: Maybe<Array<Scalars["String"]>>;
  description_not_in?: Maybe<Array<Scalars["String"]>>;
  description_contains?: Maybe<Scalars["String"]>;
  description_not_contains?: Maybe<Scalars["String"]>;
  description_starts_with?: Maybe<Scalars["String"]>;
  description_not_starts_with?: Maybe<Scalars["String"]>;
  description_ends_with?: Maybe<Scalars["String"]>;
  description_not_ends_with?: Maybe<Scalars["String"]>;
  friends?: Maybe<_UserFilter>;
  friends_not?: Maybe<_UserFilter>;
  friends_in?: Maybe<Array<_UserFilter>>;
  friends_not_in?: Maybe<Array<_UserFilter>>;
  friends_some?: Maybe<_UserFilter>;
  friends_none?: Maybe<_UserFilter>;
  friends_single?: Maybe<_UserFilter>;
  friends_every?: Maybe<_UserFilter>;
};

export type User = {
  __typename?: "User";
  uuid: Scalars["ID"];
  email?: Maybe<Scalars["String"]>;
  username: Scalars["String"];
  password?: Maybe<Scalars["String"]>;
  roles?: Maybe<Array<Maybe<Role>>>;
  description?: Maybe<Scalars["String"]>;
  friends?: Maybe<Array<Maybe<User>>>;
  /** Generated field for querying the Neo4j [system id](https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-id) of this node. */
  _id?: Maybe<Scalars["String"]>;
};


export type UserFriendsArgs = {
  first?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  orderBy?: Maybe<Array<Maybe<_UserOrdering>>>;
  filter?: Maybe<_UserFilter>;
};

/** Generated Time input object for Neo4j [Temporal field arguments](https://grandstack.io/docs/graphql-temporal-types-datetime/#temporal-query-arguments). */
export type _Neo4jTimeInput = {
  hour?: Maybe<Scalars["Int"]>;
  minute?: Maybe<Scalars["Int"]>;
  second?: Maybe<Scalars["Int"]>;
  millisecond?: Maybe<Scalars["Int"]>;
  microsecond?: Maybe<Scalars["Int"]>;
  nanosecond?: Maybe<Scalars["Int"]>;
  timezone?: Maybe<Scalars["String"]>;
  /** Creates a Neo4j [Temporal](https://grandstack.io/docs/graphql-temporal-types-datetime/#using-temporal-fields-in-mutations) Time value using a [String format](https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/#functions-time-create-string). */
  formatted?: Maybe<Scalars["String"]>;
};

/** Generated Time object type for Neo4j [Temporal fields](https://grandstack.io/docs/graphql-temporal-types-datetime#using-temporal-fields-in-queries). */
export type _Neo4jTime = {
  __typename?: "_Neo4jTime";
  hour?: Maybe<Scalars["Int"]>;
  minute?: Maybe<Scalars["Int"]>;
  second?: Maybe<Scalars["Int"]>;
  millisecond?: Maybe<Scalars["Int"]>;
  microsecond?: Maybe<Scalars["Int"]>;
  nanosecond?: Maybe<Scalars["Int"]>;
  timezone?: Maybe<Scalars["String"]>;
  /** Outputs a Neo4j [Temporal](https://grandstack.io/docs/graphql-temporal-types-datetime#using-temporal-fields-in-queries) Time value as a String type by using the [toString](https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-tostring) Cypher function. */
  formatted?: Maybe<Scalars["String"]>;
};

/** Generated Date input object for Neo4j [Temporal field arguments](https://grandstack.io/docs/graphql-temporal-types-datetime/#temporal-query-arguments). */
export type _Neo4jDateInput = {
  year?: Maybe<Scalars["Int"]>;
  month?: Maybe<Scalars["Int"]>;
  day?: Maybe<Scalars["Int"]>;
  /** Creates a Neo4j [Temporal](https://grandstack.io/docs/graphql-temporal-types-datetime/#using-temporal-fields-in-mutations) Date value using a [String format](https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/#functions-date-create-string). */
  formatted?: Maybe<Scalars["String"]>;
};

/** Generated Date object type for Neo4j [Temporal fields](https://grandstack.io/docs/graphql-temporal-types-datetime#using-temporal-fields-in-queries). */
export type _Neo4jDate = {
  __typename?: "_Neo4jDate";
  year?: Maybe<Scalars["Int"]>;
  month?: Maybe<Scalars["Int"]>;
  day?: Maybe<Scalars["Int"]>;
  /** Outputs a Neo4j [Temporal](https://grandstack.io/docs/graphql-temporal-types-datetime#using-temporal-fields-in-queries) Date value as a String type by using the [toString](https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-tostring) Cypher function. */
  formatted?: Maybe<Scalars["String"]>;
};

/** Generated DateTime input object for Neo4j [Temporal field arguments](https://grandstack.io/docs/graphql-temporal-types-datetime/#temporal-query-arguments). */
export type _Neo4jDateTimeInput = {
  year?: Maybe<Scalars["Int"]>;
  month?: Maybe<Scalars["Int"]>;
  day?: Maybe<Scalars["Int"]>;
  hour?: Maybe<Scalars["Int"]>;
  minute?: Maybe<Scalars["Int"]>;
  second?: Maybe<Scalars["Int"]>;
  millisecond?: Maybe<Scalars["Int"]>;
  microsecond?: Maybe<Scalars["Int"]>;
  nanosecond?: Maybe<Scalars["Int"]>;
  timezone?: Maybe<Scalars["String"]>;
  /** Creates a Neo4j [Temporal](https://grandstack.io/docs/graphql-temporal-types-datetime/#using-temporal-fields-in-mutations) DateTime value using a [String format](https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/#functions-datetime-create-string). */
  formatted?: Maybe<Scalars["String"]>;
};

/** Generated DateTime object type for Neo4j [Temporal fields](https://grandstack.io/docs/graphql-temporal-types-datetime#using-temporal-fields-in-queries). */
export type _Neo4jDateTime = {
  __typename?: "_Neo4jDateTime";
  year?: Maybe<Scalars["Int"]>;
  month?: Maybe<Scalars["Int"]>;
  day?: Maybe<Scalars["Int"]>;
  hour?: Maybe<Scalars["Int"]>;
  minute?: Maybe<Scalars["Int"]>;
  second?: Maybe<Scalars["Int"]>;
  millisecond?: Maybe<Scalars["Int"]>;
  microsecond?: Maybe<Scalars["Int"]>;
  nanosecond?: Maybe<Scalars["Int"]>;
  timezone?: Maybe<Scalars["String"]>;
  /** Outputs a Neo4j [Temporal](https://grandstack.io/docs/graphql-temporal-types-datetime#using-temporal-fields-in-queries) DateTime value as a String type by using the [toString](https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-tostring) Cypher function. */
  formatted?: Maybe<Scalars["String"]>;
};

/** Generated LocalTime input object for Neo4j [Temporal field arguments](https://grandstack.io/docs/graphql-temporal-types-datetime/#temporal-query-arguments). */
export type _Neo4jLocalTimeInput = {
  hour?: Maybe<Scalars["Int"]>;
  minute?: Maybe<Scalars["Int"]>;
  second?: Maybe<Scalars["Int"]>;
  millisecond?: Maybe<Scalars["Int"]>;
  microsecond?: Maybe<Scalars["Int"]>;
  nanosecond?: Maybe<Scalars["Int"]>;
  /** Creates a Neo4j [Temporal](https://grandstack.io/docs/graphql-temporal-types-datetime/#using-temporal-fields-in-mutations) LocalTime value using a [String format](https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/#functions-localtime-create-string). */
  formatted?: Maybe<Scalars["String"]>;
};

/** Generated LocalTime object type for Neo4j [Temporal fields](https://grandstack.io/docs/graphql-temporal-types-datetime#using-temporal-fields-in-queries). */
export type _Neo4jLocalTime = {
  __typename?: "_Neo4jLocalTime";
  hour?: Maybe<Scalars["Int"]>;
  minute?: Maybe<Scalars["Int"]>;
  second?: Maybe<Scalars["Int"]>;
  millisecond?: Maybe<Scalars["Int"]>;
  microsecond?: Maybe<Scalars["Int"]>;
  nanosecond?: Maybe<Scalars["Int"]>;
  /** Outputs a Neo4j [Temporal](https://grandstack.io/docs/graphql-temporal-types-datetime#using-temporal-fields-in-queries) LocalTime value as a String type by using the [toString](https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-tostring) Cypher function. */
  formatted?: Maybe<Scalars["String"]>;
};

/** Generated LocalDateTime input object for Neo4j [Temporal field arguments](https://grandstack.io/docs/graphql-temporal-types-datetime/#temporal-query-arguments). */
export type _Neo4jLocalDateTimeInput = {
  year?: Maybe<Scalars["Int"]>;
  month?: Maybe<Scalars["Int"]>;
  day?: Maybe<Scalars["Int"]>;
  hour?: Maybe<Scalars["Int"]>;
  minute?: Maybe<Scalars["Int"]>;
  second?: Maybe<Scalars["Int"]>;
  millisecond?: Maybe<Scalars["Int"]>;
  microsecond?: Maybe<Scalars["Int"]>;
  nanosecond?: Maybe<Scalars["Int"]>;
  /** Creates a Neo4j [Temporal](https://grandstack.io/docs/graphql-temporal-types-datetime/#using-temporal-fields-in-mutations) LocalDateTime value using a [String format](https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/#functions-localdatetime-create-string). */
  formatted?: Maybe<Scalars["String"]>;
};

/** Generated LocalDateTime object type for Neo4j [Temporal fields](https://grandstack.io/docs/graphql-temporal-types-datetime#using-temporal-fields-in-queries). */
export type _Neo4jLocalDateTime = {
  __typename?: "_Neo4jLocalDateTime";
  year?: Maybe<Scalars["Int"]>;
  month?: Maybe<Scalars["Int"]>;
  day?: Maybe<Scalars["Int"]>;
  hour?: Maybe<Scalars["Int"]>;
  minute?: Maybe<Scalars["Int"]>;
  second?: Maybe<Scalars["Int"]>;
  millisecond?: Maybe<Scalars["Int"]>;
  microsecond?: Maybe<Scalars["Int"]>;
  nanosecond?: Maybe<Scalars["Int"]>;
  /** Outputs a Neo4j [Temporal](https://grandstack.io/docs/graphql-temporal-types-datetime#using-temporal-fields-in-queries) LocalDateTime value as a String type by using the [toString](https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-tostring) Cypher function. */
  formatted?: Maybe<Scalars["String"]>;
};

export type _Neo4jPointDistanceFilter = {
  point: _Neo4jPointInput;
  distance: Scalars["Float"];
};

/** Generated Point input object for Neo4j [Spatial field arguments](https://grandstack.io/docs/graphql-spatial-types/#point-query-arguments). */
export type _Neo4jPointInput = {
  x?: Maybe<Scalars["Float"]>;
  y?: Maybe<Scalars["Float"]>;
  z?: Maybe<Scalars["Float"]>;
  longitude?: Maybe<Scalars["Float"]>;
  latitude?: Maybe<Scalars["Float"]>;
  height?: Maybe<Scalars["Float"]>;
  crs?: Maybe<Scalars["String"]>;
  srid?: Maybe<Scalars["Int"]>;
};

/** Generated Point object type for Neo4j [Spatial fields](https://grandstack.io/docs/graphql-spatial-types#using-point-in-queries). */
export type _Neo4jPoint = {
  __typename?: "_Neo4jPoint";
  x?: Maybe<Scalars["Float"]>;
  y?: Maybe<Scalars["Float"]>;
  z?: Maybe<Scalars["Float"]>;
  longitude?: Maybe<Scalars["Float"]>;
  latitude?: Maybe<Scalars["Float"]>;
  height?: Maybe<Scalars["Float"]>;
  crs?: Maybe<Scalars["String"]>;
  srid?: Maybe<Scalars["Int"]>;
};

export enum _RelationDirections {
  In = "IN",
  Out = "OUT"
}

export type Mutation = {
  __typename?: "Mutation";
  CreateUser?: Maybe<User>;
  DeleteMe?: Maybe<Scalars["Boolean"]>;
  SignIn?: Maybe<User>;
  SignOut?: Maybe<Scalars["Boolean"]>;
  SignUp?: Maybe<User>;
  UpdateMe?: Maybe<Scalars["Boolean"]>;
  UpdateUser?: Maybe<Scalars["Boolean"]>;
};


export type MutationCreateUserArgs = {
  email: Scalars["String"];
  password: Scalars["String"];
  username: Scalars["String"];
  roles: Array<Role>;
};


export type MutationSignInArgs = {
  email?: Maybe<Scalars["String"]>;
  username?: Maybe<Scalars["String"]>;
  password: Scalars["String"];
};


export type MutationSignUpArgs = {
  email: Scalars["String"];
  username: Scalars["String"];
  password: Scalars["String"];
};


export type MutationUpdateMeArgs = {
  email?: Maybe<Scalars["String"]>;
  username?: Maybe<Scalars["String"]>;
  description?: Maybe<Scalars["String"]>;
};


export type MutationUpdateUserArgs = {
  userUUID: Scalars["ID"];
  email?: Maybe<Scalars["String"]>;
  username?: Maybe<Scalars["String"]>;
  description?: Maybe<Scalars["String"]>;
};

export type Query = {
  __typename?: "Query";
  Me?: Maybe<User>;
  /** [Generated query](https://grandstack.io/docs/graphql-schema-generation-augmentation#generated-queries) for User type nodes. */
  User?: Maybe<Array<Maybe<User>>>;
};


export type QueryUserArgs = {
  uuid?: Maybe<Scalars["ID"]>;
  email?: Maybe<Scalars["String"]>;
  username?: Maybe<Scalars["String"]>;
  password?: Maybe<Scalars["String"]>;
  roles?: Maybe<Array<Maybe<Role>>>;
  description?: Maybe<Scalars["String"]>;
  _id?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  orderBy?: Maybe<Array<Maybe<_UserOrdering>>>;
  filter?: Maybe<_UserFilter>;
};

export type MiniUserFieldsFragment = (
  { __typename: "User" }
  & Pick<User, "uuid" | "username">
);

export type UserFieldsFragment = (
  { __typename: "User" }
  & Pick<User, "uuid" | "username" | "description">
);

export type DeleteMeMutationVariables = Exact<{ [key: string]: never; }>;


export type DeleteMeMutation = (
  { __typename?: "Mutation" }
  & Pick<Mutation, "DeleteMe">
);

export type SignInMutationVariables = Exact<{
  email?: Maybe<Scalars["String"]>;
  username?: Maybe<Scalars["String"]>;
  password: Scalars["String"];
}>;


export type SignInMutation = (
  { __typename?: "Mutation" }
  & { SignIn?: Maybe<(
    { __typename?: "User" }
    & MiniUserFieldsFragment
  )> }
);

export type SignOutMutationVariables = Exact<{ [key: string]: never; }>;


export type SignOutMutation = (
  { __typename?: "Mutation" }
  & Pick<Mutation, "SignOut">
);

export type SignUpMutationVariables = Exact<{
  email: Scalars["String"];
  password: Scalars["String"];
  username: Scalars["String"];
}>;


export type SignUpMutation = (
  { __typename?: "Mutation" }
  & { SignUp?: Maybe<(
    { __typename?: "User" }
    & MiniUserFieldsFragment
  )> }
);

export type UpdateMeMutationVariables = Exact<{
  email?: Maybe<Scalars["String"]>;
  username?: Maybe<Scalars["String"]>;
  description?: Maybe<Scalars["String"]>;
}>;


export type UpdateMeMutation = (
  { __typename?: "Mutation" }
  & Pick<Mutation, "UpdateMe">
);

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = (
  { __typename?: "Query" }
  & { Me?: Maybe<(
    { __typename?: "User" }
    & UserFieldsFragment
  )> }
);

export type MiniMeQueryVariables = Exact<{ [key: string]: never; }>;


export type MiniMeQuery = (
  { __typename?: "Query" }
  & { Me?: Maybe<(
    { __typename?: "User" }
    & MiniUserFieldsFragment
  )> }
);

export type UserQueryVariables = Exact<{
  uuid: Scalars["ID"];
}>;


export type UserQuery = (
  { __typename?: "Query" }
  & { User?: Maybe<Array<Maybe<(
    { __typename?: "User" }
    & UserFieldsFragment
  )>>> }
);

export const MiniUserFieldsFragmentDoc = gql`
    fragment miniUserFields on User {
  __typename
  uuid
  username
}
    `;
export const UserFieldsFragmentDoc = gql`
    fragment userFields on User {
  __typename
  uuid
  username
  description
}
    `;
export const DeleteMeDocument = gql`
    mutation DeleteMe {
  DeleteMe
}
    `;
export type DeleteMeMutationFn = Apollo.MutationFunction<DeleteMeMutation, DeleteMeMutationVariables>;

/**
 * __useDeleteMeMutation__
 *
 * To run a mutation, you first call `useDeleteMeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteMeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteMeMutation, { data, loading, error }] = useDeleteMeMutation({
 *   variables: {
 *   },
 * });
 */
export function useDeleteMeMutation(baseOptions?: Apollo.MutationHookOptions<DeleteMeMutation, DeleteMeMutationVariables>) {
  return Apollo.useMutation<DeleteMeMutation, DeleteMeMutationVariables>(DeleteMeDocument, baseOptions);
}
export type DeleteMeMutationHookResult = ReturnType<typeof useDeleteMeMutation>;
export type DeleteMeMutationResult = Apollo.MutationResult<DeleteMeMutation>;
export type DeleteMeMutationOptions = Apollo.BaseMutationOptions<DeleteMeMutation, DeleteMeMutationVariables>;
export const SignInDocument = gql`
    mutation SignIn($email: String, $username: String, $password: String!) {
  SignIn(email: $email, username: $username, password: $password) {
    ...miniUserFields
  }
}
    ${MiniUserFieldsFragmentDoc}`;
export type SignInMutationFn = Apollo.MutationFunction<SignInMutation, SignInMutationVariables>;

/**
 * __useSignInMutation__
 *
 * To run a mutation, you first call `useSignInMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignInMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signInMutation, { data, loading, error }] = useSignInMutation({
 *   variables: {
 *      email: // value for 'email'
 *      username: // value for 'username'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useSignInMutation(baseOptions?: Apollo.MutationHookOptions<SignInMutation, SignInMutationVariables>) {
  return Apollo.useMutation<SignInMutation, SignInMutationVariables>(SignInDocument, baseOptions);
}
export type SignInMutationHookResult = ReturnType<typeof useSignInMutation>;
export type SignInMutationResult = Apollo.MutationResult<SignInMutation>;
export type SignInMutationOptions = Apollo.BaseMutationOptions<SignInMutation, SignInMutationVariables>;
export const SignOutDocument = gql`
    mutation SignOut {
  SignOut
}
    `;
export type SignOutMutationFn = Apollo.MutationFunction<SignOutMutation, SignOutMutationVariables>;

/**
 * __useSignOutMutation__
 *
 * To run a mutation, you first call `useSignOutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignOutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signOutMutation, { data, loading, error }] = useSignOutMutation({
 *   variables: {
 *   },
 * });
 */
export function useSignOutMutation(baseOptions?: Apollo.MutationHookOptions<SignOutMutation, SignOutMutationVariables>) {
  return Apollo.useMutation<SignOutMutation, SignOutMutationVariables>(SignOutDocument, baseOptions);
}
export type SignOutMutationHookResult = ReturnType<typeof useSignOutMutation>;
export type SignOutMutationResult = Apollo.MutationResult<SignOutMutation>;
export type SignOutMutationOptions = Apollo.BaseMutationOptions<SignOutMutation, SignOutMutationVariables>;
export const SignUpDocument = gql`
    mutation SignUp($email: String!, $password: String!, $username: String!) {
  SignUp(email: $email, password: $password, username: $username) {
    ...miniUserFields
  }
}
    ${MiniUserFieldsFragmentDoc}`;
export type SignUpMutationFn = Apollo.MutationFunction<SignUpMutation, SignUpMutationVariables>;

/**
 * __useSignUpMutation__
 *
 * To run a mutation, you first call `useSignUpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignUpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signUpMutation, { data, loading, error }] = useSignUpMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *      username: // value for 'username'
 *   },
 * });
 */
export function useSignUpMutation(baseOptions?: Apollo.MutationHookOptions<SignUpMutation, SignUpMutationVariables>) {
  return Apollo.useMutation<SignUpMutation, SignUpMutationVariables>(SignUpDocument, baseOptions);
}
export type SignUpMutationHookResult = ReturnType<typeof useSignUpMutation>;
export type SignUpMutationResult = Apollo.MutationResult<SignUpMutation>;
export type SignUpMutationOptions = Apollo.BaseMutationOptions<SignUpMutation, SignUpMutationVariables>;
export const UpdateMeDocument = gql`
    mutation UpdateMe($email: String, $username: String, $description: String) {
  UpdateMe(email: $email, username: $username, description: $description)
}
    `;
export type UpdateMeMutationFn = Apollo.MutationFunction<UpdateMeMutation, UpdateMeMutationVariables>;

/**
 * __useUpdateMeMutation__
 *
 * To run a mutation, you first call `useUpdateMeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMeMutation, { data, loading, error }] = useUpdateMeMutation({
 *   variables: {
 *      email: // value for 'email'
 *      username: // value for 'username'
 *      description: // value for 'description'
 *   },
 * });
 */
export function useUpdateMeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMeMutation, UpdateMeMutationVariables>) {
  return Apollo.useMutation<UpdateMeMutation, UpdateMeMutationVariables>(UpdateMeDocument, baseOptions);
}
export type UpdateMeMutationHookResult = ReturnType<typeof useUpdateMeMutation>;
export type UpdateMeMutationResult = Apollo.MutationResult<UpdateMeMutation>;
export type UpdateMeMutationOptions = Apollo.BaseMutationOptions<UpdateMeMutation, UpdateMeMutationVariables>;
export const MeDocument = gql`
    query Me {
  Me {
    ...userFields
  }
}
    ${UserFieldsFragmentDoc}`;

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>) {
  return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, baseOptions);
}
export function useMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>) {
  return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, baseOptions);
}
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;
export const MiniMeDocument = gql`
    query MiniMe {
  Me {
    ...miniUserFields
  }
}
    ${MiniUserFieldsFragmentDoc}`;

/**
 * __useMiniMeQuery__
 *
 * To run a query within a React component, call `useMiniMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMiniMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMiniMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMiniMeQuery(baseOptions?: Apollo.QueryHookOptions<MiniMeQuery, MiniMeQueryVariables>) {
  return Apollo.useQuery<MiniMeQuery, MiniMeQueryVariables>(MiniMeDocument, baseOptions);
}
export function useMiniMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MiniMeQuery, MiniMeQueryVariables>) {
  return Apollo.useLazyQuery<MiniMeQuery, MiniMeQueryVariables>(MiniMeDocument, baseOptions);
}
export type MiniMeQueryHookResult = ReturnType<typeof useMiniMeQuery>;
export type MiniMeLazyQueryHookResult = ReturnType<typeof useMiniMeLazyQuery>;
export type MiniMeQueryResult = Apollo.QueryResult<MiniMeQuery, MiniMeQueryVariables>;
export const UserDocument = gql`
    query User($uuid: ID!) {
  User(uuid: $uuid) {
    ...userFields
  }
}
    ${UserFieldsFragmentDoc}`;

/**
 * __useUserQuery__
 *
 * To run a query within a React component, call `useUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserQuery({
 *   variables: {
 *      uuid: // value for 'uuid'
 *   },
 * });
 */
export function useUserQuery(baseOptions: Apollo.QueryHookOptions<UserQuery, UserQueryVariables>) {
  return Apollo.useQuery<UserQuery, UserQueryVariables>(UserDocument, baseOptions);
}
export function useUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserQuery, UserQueryVariables>) {
  return Apollo.useLazyQuery<UserQuery, UserQueryVariables>(UserDocument, baseOptions);
}
export type UserQueryHookResult = ReturnType<typeof useUserQuery>;
export type UserLazyQueryHookResult = ReturnType<typeof useUserLazyQuery>;
export type UserQueryResult = Apollo.QueryResult<UserQuery, UserQueryVariables>;

export interface IntrospectionResultData {
        __schema: {
          types: {
            kind: string;
            name: string;
            possibleTypes: {
              name: string;
            }[];
          }[];
        };
      }
const result: IntrospectionResultData = {
  "__schema": {
    "types": []
  }
};
export default result;
    